"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Etherscan = void 0;
const errors_1 = require("./errors");
const undici_1 = require("./undici");
const utilities_1 = require("./utilities");
// Used for polling the result of the contract verification.
const VERIFICATION_STATUS_POLLING_TIME = 3000;
class Etherscan {
    constructor(apiKey, chainConfig) {
        this._apiKey = resolveApiKey(apiKey, chainConfig.network);
        this._apiUrl = chainConfig.urls.apiURL;
        this._browserUrl = chainConfig.urls.browserURL.trim().replace(/\/$/, "");
    }
    // https://docs.etherscan.io/api-endpoints/contracts#get-contract-source-code-for-verified-contract-source-codes
    async isVerified(address) {
        const parameters = new URLSearchParams({
            apikey: this._apiKey,
            module: "contract",
            action: "getsourcecode",
            address,
        });
        const url = new URL(this._apiUrl);
        url.search = parameters.toString();
        const response = await (0, undici_1.sendGetRequest)(url);
        const json = await response.body.json();
        if (json.message !== "OK") {
            return false;
        }
        const sourceCode = json?.result?.[0]?.SourceCode;
        return sourceCode !== undefined && sourceCode !== "";
    }
    // https://docs.etherscan.io/api-endpoints/contracts#verify-source-code
    async verify({ address, sourceCode, sourceName, contractName, compilerVersion, encodedConstructorArguments, }) {
        const parameters = new URLSearchParams({
            apikey: this._apiKey,
            module: "contract",
            action: "verifysourcecode",
            contractaddress: address,
            sourceCode,
            codeformat: "solidity-standard-json-input",
            contractname: `${sourceName}:${contractName}`,
            compilerversion: `v${compilerVersion}`,
            constructorArguements: encodedConstructorArguments,
        });
        let response;
        try {
            response = await (0, undici_1.sendPostRequest)(new URL(this._apiUrl), parameters.toString());
        }
        catch (error) {
            throw new errors_1.ContractVerificationRequestError(this._apiUrl, error);
        }
        if (!(response.statusCode >= 200 && response.statusCode <= 299)) {
            // This could be always interpreted as JSON if there were any such guarantee in the Etherscan API.
            const responseText = await response.body.text();
            throw new errors_1.ContractVerificationInvalidStatusCodeError(this._apiUrl, response.statusCode, responseText);
        }
        const etherscanResponse = new EtherscanResponse(await response.body.json());
        if (etherscanResponse.isBytecodeMissingInNetworkError()) {
            throw new errors_1.ContractVerificationMissingBytecodeError(this._apiUrl, address);
        }
        if (!etherscanResponse.isOk()) {
            throw new errors_1.HardhatVerifyError(etherscanResponse.message);
        }
        return etherscanResponse;
    }
    // https://docs.etherscan.io/api-endpoints/contracts#check-source-code-verification-submission-status
    async getVerificationStatus(guid) {
        const parameters = new URLSearchParams({
            apikey: this._apiKey,
            module: "contract",
            action: "checkverifystatus",
            guid,
        });
        const url = new URL(this._apiUrl);
        url.search = parameters.toString();
        let response;
        try {
            response = await (0, undici_1.sendGetRequest)(url);
        }
        catch (error) {
            throw new errors_1.ContractStatusPollingError(url.toString(), error);
        }
        if (!(response.statusCode >= 200 && response.statusCode <= 299)) {
            // This could be always interpreted as JSON if there were any such guarantee in the Etherscan API.
            const responseText = await response.body.text();
            throw new errors_1.ContractStatusPollingInvalidStatusCodeError(response.statusCode, responseText);
        }
        const etherscanResponse = new EtherscanResponse(await response.body.json());
        if (etherscanResponse.isPending()) {
            await (0, utilities_1.sleep)(VERIFICATION_STATUS_POLLING_TIME);
            return this.getVerificationStatus(guid);
        }
        if (etherscanResponse.isFailure()) {
            return etherscanResponse;
        }
        if (!etherscanResponse.isOk()) {
            throw new errors_1.ContractStatusPollingResponseNotOkError(etherscanResponse.message);
        }
        return etherscanResponse;
    }
    getContractUrl(address) {
        return `${this._browserUrl}/address/${address}#code`;
    }
}
exports.Etherscan = Etherscan;
class EtherscanResponse {
    constructor(response) {
        this.status = parseInt(response.status, 10);
        this.message = response.result;
    }
    isPending() {
        return this.message === "Pending in queue";
    }
    isFailure() {
        return this.message === "Fail - Unable to verify";
    }
    isSuccess() {
        return this.message === "Pass - Verified";
    }
    isBytecodeMissingInNetworkError() {
        return this.message.startsWith("Unable to locate ContractCode at");
    }
    isOk() {
        return this.status === 1;
    }
}
function resolveApiKey(apiKey, network) {
    if (apiKey === undefined || apiKey === "") {
        throw new errors_1.MissingApiKeyError(network);
    }
    if (typeof apiKey === "string") {
        return apiKey;
    }
    const key = apiKey[network];
    if (key === undefined || key === "") {
        throw new errors_1.MissingApiKeyError(network);
    }
    return key;
}
//# sourceMappingURL=etherscan.js.map